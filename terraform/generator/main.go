package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

type ResourceDefinition struct {
	Name        string            `json:"name"`
	Type        string            `json:"type"`
	Description string            `json:"description"`
	Attributes  []Attribute       `json:"attributes"`
	Required    []string          `json:"required"`
	Optional    []string          `json:"optional"`
	Computed    []string          `json:"computed"`
	Tags        map[string]string `json:"tags"`
}

type Attribute struct {
	Name        string      `json:"name"`
	Type        string      `json:"type"`
	Description string      `json:"description"`
	Required    bool        `json:"required"`
	Optional    bool        `json:"optional"`
	Computed    bool        `json:"computed"`
	Default     interface{} `json:"default,omitempty"`
	Validation  *Validation `json:"validation,omitempty"`
}

type Validation struct {
	MinLength *int    `json:"min_length,omitempty"`
	MaxLength *int    `json:"max_length,omitempty"`
	Pattern   *string `json:"pattern,omitempty"`
	Min       *int    `json:"min,omitempty"`
	Max       *int    `json:"max,omitempty"`
}

type ProviderConfig struct {
	Name        string              `json:"name"`
	Version     string              `json:"version"`
	Description string              `json:"description"`
	Resources   []ResourceDefinition `json:"resources"`
	DataSources []ResourceDefinition `json:"data_sources"`
}

const providerTemplate = `// Code generated by terraform-generator. DO NOT EDIT.
package {{.Name}}

import (
	"context"
	"fmt"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
)

// Provider returns a terraform provider instance
func Provider() *schema.Provider {
	return &schema.Provider{
		Schema: map[string]*schema.Schema{
			"api_url": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "API URL for {{.Name}}",
				DefaultFunc: schema.EnvDefaultFunc("{{.Name | upper}}_API_URL", nil),
			},
			"api_key": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "API Key for {{.Name}}",
				DefaultFunc: schema.EnvDefaultFunc("{{.Name | upper}}_API_KEY", nil),
			},
			"timeout": {
				Type:        schema.TypeInt,
				Optional:    true,
				Description: "Request timeout in seconds",
				Default:     30,
			},
		},
		ResourcesMap: map[string]*schema.Resource{
{{range .Resources}}			"{{.Name}}": resource{{.Type | title}}(),
{{end}}		},
		DataSourcesMap: map[string]*schema.Resource{
{{range .DataSources}}			"{{.Name}}": dataSource{{.Type | title}}(),
{{end}}		},
		ConfigureContextFunc: providerConfigure,
	}
}

func providerConfigure(ctx context.Context, d *schema.ResourceData) (interface{}, diag.Diagnostics) {
	apiURL := d.Get("api_url").(string)
	apiKey := d.Get("api_key").(string)
	timeout := d.Get("timeout").(int)

	config := &Config{
		APIURL:   apiURL,
		APIKey:   apiKey,
		Timeout:  time.Duration(timeout) * time.Second,
	}

	client, err := NewClient(config)
	if err != nil {
		return nil, diag.FromErr(err)
	}

	return client, nil
}

type Config struct {
	APIURL  string
	APIKey  string
	Timeout time.Duration
}

type Client struct {
	config *Config
	// Add HTTP client and other dependencies here
}

func NewClient(config *Config) (*Client, error) {
	return &Client{
		config: config,
	}, nil
}
`

const resourceTemplate = `// Code generated by terraform-generator. DO NOT EDIT.
package {{.ProviderName}}

import (
	"context"
	"fmt"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
)

func resource{{.Type | title}}() *schema.Resource {
	return &schema.Resource{
		CreateContext: resource{{.Type | title}}Create,
		ReadContext:   resource{{.Type | title}}Read,
		UpdateContext: resource{{.Type | title}}Update,
		DeleteContext: resource{{.Type | title}}Delete,
		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},
		Schema: map[string]*schema.Schema{
{{range .Attributes}}			"{{.Name}}": {
				Type:        schema.Type{{.Type | title}},
				{{if .Required}}Required:    true,{{end}}
				{{if .Optional}}Optional:    true,{{end}}
				{{if .Computed}}Computed:    true,{{end}}
				Description: "{{.Description}}",
				{{if .Default}}Default:     {{.Default | printf "%#v"}},{{end}}
				{{if .Validation}}{{if .Validation.MinLength}}ValidateFunc: validation.StringLenBetween({{.Validation.MinLength}}, {{.Validation.MaxLength}}),{{end}}
				{{if .Validation.Pattern}}ValidateFunc: validation.StringMatch(regexp.MustCompile({{.Validation.Pattern | printf "%q"}}), "Invalid format"),{{end}}
				{{if .Validation.Min}}ValidateFunc: validation.IntBetween({{.Validation.Min}}, {{.Validation.Max}}),{{end}}{{end}}
			},
{{end}}		},
		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(10 * time.Minute),
			Read:   schema.DefaultTimeout(5 * time.Minute),
			Update: schema.DefaultTimeout(10 * time.Minute),
			Delete: schema.DefaultTimeout(10 * time.Minute),
		},
	}
}

func resource{{.Type | title}}Create(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	client := m.(*Client)
	
	// TODO: Implement create logic
	// Example:
	// resource := &{{.Type | title}}{
	//     Name: d.Get("name").(string),
	//     // ... other fields
	// }
	// 
	// created, err := client.Create{{.Type | title}}(resource)
	// if err != nil {
	//     return diag.FromErr(err)
	// }
	// 
	// d.SetId(created.ID)
	
	return resource{{.Type | title}}Read(ctx, d, m)
}

func resource{{.Type | title}}Read(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	client := m.(*Client)
	
	// TODO: Implement read logic
	// Example:
	// resource, err := client.Get{{.Type | title}}(d.Id())
	// if err != nil {
	//     return diag.FromErr(err)
	// }
	// 
	// d.Set("name", resource.Name)
	// ... set other fields
	
	return nil
}

func resource{{.Type | title}}Update(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	client := m.(*Client)
	
	// TODO: Implement update logic
	// Example:
	// resource := &{{.Type | title}}{
	//     ID:   d.Id(),
	//     Name: d.Get("name").(string),
	//     // ... other fields
	// }
	// 
	// _, err := client.Update{{.Type | title}}(resource)
	// if err != nil {
	//     return diag.FromErr(err)
	// }
	
	return resource{{.Type | title}}Read(ctx, d, m)
}

func resource{{.Type | title}}Delete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	client := m.(*Client)
	
	// TODO: Implement delete logic
	// Example:
	// err := client.Delete{{.Type | title}}(d.Id())
	// if err != nil {
	//     return diag.FromErr(err)
	// }
	
	return nil
}
`

const dataSourceTemplate = `// Code generated by terraform-generator. DO NOT EDIT.
package {{.ProviderName}}

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func dataSource{{.Type | title}}() *schema.Resource {
	return &schema.Resource{
		ReadContext: dataSource{{.Type | title}}Read,
		Schema: map[string]*schema.Schema{
{{range .Attributes}}			"{{.Name}}": {
				Type:        schema.Type{{.Type | title}},
				{{if .Required}}Required:    true,{{end}}
				{{if .Optional}}Optional:    true,{{end}}
				{{if .Computed}}Computed:    true,{{end}}
				Description: "{{.Description}}",
			},
{{end}}		},
	}
}

func dataSource{{.Type | title}}Read(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	client := m.(*Client)
	
	// TODO: Implement read logic
	// Example:
	// id := d.Get("id").(string)
	// resource, err := client.Get{{.Type | title}}(id)
	// if err != nil {
	//     return diag.FromErr(err)
	// }
	// 
	// d.SetId(resource.ID)
	// d.Set("name", resource.Name)
	// ... set other fields
	
	return nil
}
`

func main() {
	if len(os.Args) < 2 {
		fmt.Println("Usage: terraform-generator <config.json>")
		os.Exit(1)
	}

	configFile := os.Args[1]
	
	// Read configuration
	configData, err := ioutil.ReadFile(configFile)
	if err != nil {
		fmt.Printf("Error reading config file: %v\n", err)
		os.Exit(1)
	}

	var config ProviderConfig
	if err := json.Unmarshal(configData, &config); err != nil {
		fmt.Printf("Error parsing config file: %v\n", err)
		os.Exit(1)
	}

	// Create output directory
	outputDir := fmt.Sprintf("providers/%s", config.Name)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		fmt.Printf("Error creating output directory: %v\n", err)
		os.Exit(1)
	}

	// Generate provider file
	providerFile := filepath.Join(outputDir, "provider.go")
	if err := generateFile(providerFile, providerTemplate, config); err != nil {
		fmt.Printf("Error generating provider file: %v\n", err)
		os.Exit(1)
	}

	// Generate resource files
	for _, resource := range config.Resources {
		resourceFile := filepath.Join(outputDir, fmt.Sprintf("resource_%s.go", resource.Name))
		data := struct {
			ProviderName string
			ResourceDefinition
		}{
			ProviderName:       config.Name,
			ResourceDefinition: resource,
		}
		if err := generateFile(resourceFile, resourceTemplate, data); err != nil {
			fmt.Printf("Error generating resource file %s: %v\n", resource.Name, err)
			os.Exit(1)
		}
	}

	// Generate data source files
	for _, dataSource := range config.DataSources {
		dataSourceFile := filepath.Join(outputDir, fmt.Sprintf("data_source_%s.go", dataSource.Name))
		data := struct {
			ProviderName string
			ResourceDefinition
		}{
			ProviderName:       config.Name,
			ResourceDefinition: dataSource,
		}
		if err := generateFile(dataSourceFile, dataSourceTemplate, data); err != nil {
			fmt.Printf("Error generating data source file %s: %v\n", dataSource.Name, err)
			os.Exit(1)
		}
	}

	// Generate go.mod file
	goModFile := filepath.Join(outputDir, "go.mod")
	goModContent := fmt.Sprintf(`module github.com/router-sim/terraform-provider-%s

go 1.21

require (
	github.com/hashicorp/terraform-plugin-sdk/v2 v2.29.0
)
`, config.Name)
	if err := ioutil.WriteFile(goModFile, []byte(goModContent), 0644); err != nil {
		fmt.Printf("Error generating go.mod file: %v\n", err)
		os.Exit(1)
	}

	// Generate main.go file
	mainFile := filepath.Join(outputDir, "main.go")
	mainContent := fmt.Sprintf(`package main

import (
	"github.com/hashicorp/terraform-plugin-sdk/v2/plugin"
	"github.com/router-sim/terraform-provider-%s/%s"
)

func main() {
	plugin.Serve(&plugin.ServeOpts{
		ProviderFunc: %s.Provider,
	})
}
`, config.Name, config.Name, config.Name)
	if err := ioutil.WriteFile(mainFile, []byte(mainContent), 0644); err != nil {
		fmt.Printf("Error generating main.go file: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Successfully generated Terraform provider for %s\n", config.Name)
	fmt.Printf("Output directory: %s\n", outputDir)
}

func generateFile(filename, templateStr string, data interface{}) error {
	tmpl, err := template.New("").Funcs(template.FuncMap{
		"title": strings.Title,
		"upper": strings.ToUpper,
	}).Parse(templateStr)
	if err != nil {
		return err
	}

	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	return tmpl.Execute(file, data)
}
